/*
 * Copyright (c) 2023-2026 "Neo4j,"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.jdbc.it.cp;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashSet;
import java.util.Objects;
import java.util.logging.ConsoleHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

import org.assertj.core.api.ThrowingConsumer;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatExceptionOfType;

class GeneratedKeysIT extends IntegrationTestBase {

	private final Handler handler;

	private Level oldLevel;

	GeneratedKeysIT() {
		this.handler = new ConsoleHandler();
		this.handler.setLevel(Level.FINE);
	}

	@BeforeAll
	void setup() {

		var sqlLogger = Logger.getLogger("org.neo4j.jdbc.statement.SQL");
		this.oldLevel = sqlLogger.getLevel();
		sqlLogger.setLevel(Level.FINE);
		sqlLogger.addHandler(this.handler);
	}

	@AfterAll
	void cleanup() {
		var sqlLogger = Logger.getLogger("org.neo4j.jdbc.statement.SQL");
		sqlLogger.setLevel(Objects.requireNonNullElse(this.oldLevel, Level.INFO));
		sqlLogger.removeHandler(this.handler);

	}

	@Test
	void plainUpdateShouldReturnKeys() throws SQLException {
		try (var con = getConnection(true, true);
				var ps = con.prepareStatement("INSERT INTO Foo(x) VALUES(?) RETURNING v$id",
						Statement.RETURN_GENERATED_KEYS)) {
			ps.setString(1, "Bar");
			var cnt = ps.executeUpdate();
			assertThat(cnt).isEqualTo(1);
			try (var rs = ps.getGeneratedKeys()) {
				assertMetaData(rs);

				assertThat(rs.next()).isTrue();
				var id = rs.getString("v$id");
				assertThat(id).isNotNull();
				assertThat(rs.next()).isFalse();
			}
		}
	}

	@ParameterizedTest
	@ValueSource(booleans = { false, true })
	void batchedUpdateShouldReturnKeys(boolean rewrite) throws SQLException {
		try (var con = getConnection(true, rewrite);
				var ps = con.prepareStatement("INSERT INTO Foo(x) VALUES(?) RETURNING v$id",
						Statement.RETURN_GENERATED_KEYS);
				var psCompare = con.prepareStatement("SELECT * FROM Foo WHERE v$id in ?");) {
			ps.setString(1, "Bar");
			ps.addBatch();
			ps.setString(1, "BazBar");
			var cnt = ps.executeBatch();
			if (rewrite) {
				assertThat(cnt).isEqualTo(new int[] { 2 });
			}
			else {
				assertThat(cnt).isEqualTo(new int[] { 1, 1 });
			}
			var ids = new HashSet<String>();
			try (var rs = ps.getGeneratedKeys()) {
				assertMetaData(rs);

				while (rs.next()) {
					ids.add(rs.getString("v$id"));
				}
			}
			assertThat(ids).hasSize(2);
			psCompare.setObject(1, ids);
			var rs = psCompare.executeQuery();
			var names = new HashSet<String>();
			while (rs.next()) {
				names.add(rs.getString("x"));
			}
			assertThat(names).containsExactlyInAnyOrder("Bar", "BazBar");
		}
	}

	@Test
	void statementShouldReturnKeysOnUpdate() throws SQLException {
		try (var con = getConnection(true, true); var stmt = con.createStatement()) {
			var cnt = stmt.executeUpdate("INSERT INTO Foo(x) VALUES('Bar') RETURNING v$id",
					Statement.RETURN_GENERATED_KEYS);

			assertThat(cnt).isEqualTo(1);
			try (var rs = stmt.getGeneratedKeys()) {
				assertMetaData(rs);

				assertThat(rs.next()).isTrue();
				var id = rs.getString("v$id");
				assertThat(id).isNotNull();
				assertThat(rs.next()).isFalse();
			}
		}
	}

	@Test
	void shouldFailPreparationOnInvalidParameterValue() throws SQLException {
		try (var con = getConnection(true, true)) {
			assertThatExceptionOfType(SQLException.class).isThrownBy(() -> con.prepareStatement("whatever", 23))
				.withMessage("general processing exception - Invalid value %d for parameter `autoGeneratedKeys`", 23);
			assertThatExceptionOfType(SQLException.class).isThrownBy(() -> con.prepareStatement("whatever", 42))
				.withMessage("general processing exception - Invalid value %d for parameter `autoGeneratedKeys`", 42);
		}
	}

	@Test
	void statementShouldReturnKeysOnExecute() throws SQLException {
		try (var con = getConnection(true, true); var stmt = con.createStatement()) {
			var cnt = stmt.execute("INSERT INTO Foo(x) VALUES('Bar') RETURNING v$id", Statement.RETURN_GENERATED_KEYS);

			assertThat(cnt).isFalse(); // It's an update
			try (var rs = stmt.getGeneratedKeys()) {
				assertMetaData(rs);

				assertThat(rs.next()).isTrue();
				var id = rs.getString("v$id");
				assertThat(id).isNotNull();
				assertThat(rs.next()).isFalse();
			}
		}
	}

	@Test
	void shouldFailStatementOnInvalidParameterValue() throws SQLException {
		try (var con = getConnection(true, true); var stmt = con.createStatement()) {
			assertThatExceptionOfType(SQLException.class).isThrownBy(() -> stmt.execute("whatever", 23))
				.withMessage("general processing exception - Invalid value %d for parameter `autoGeneratedKeys`", 23);
			assertThatExceptionOfType(SQLException.class).isThrownBy(() -> stmt.executeUpdate("whatever", 42))
				.withMessage("general processing exception - Invalid value %d for parameter `autoGeneratedKeys`", 42);
		}
	}

	Stream<Arguments> statementShouldFailWhenNoGeneratedKeysAreRequestAndUserChangesTheirMind() {

		return Stream
			.<ThrowingConsumer<Statement>>of(s -> s.execute("INSERT INTO Foo(x) VALUES('Bar') RETURNING v$id"),
					s -> s.execute("INSERT INTO Foo(x) VALUES('Bar')"),
					s -> s.executeUpdate("INSERT INTO Foo(x) VALUES('Bar') RETURNING v$id"))
			.map(Arguments::of);
	}

	@ParameterizedTest
	@MethodSource
	void statementShouldFailWhenNoGeneratedKeysAreRequestAndUserChangesTheirMind(ThrowingConsumer<Statement> preparer)
			throws Throwable {
		try (var con = getConnection(true, true); var stmt = con.createStatement()) {
			preparer.acceptThrows(stmt);
			assertThatExceptionOfType(SQLException.class).isThrownBy(stmt::getGeneratedKeys)
				.withMessageEndingWith("Generated keys have not been returned");
		}
	}

	Stream<Arguments> preparedStatementShouldFailWhenNoGeneratedKeysAreRequestAndUserChangesTheirMind() {

		return Stream
			.<ThrowingConsumer<PreparedStatement>>of(PreparedStatement::execute, PreparedStatement::executeUpdate,
					Statement::executeBatch)
			.map(Arguments::of);
	}

	@ParameterizedTest
	@MethodSource
	void preparedStatementShouldFailWhenNoGeneratedKeysAreRequestAndUserChangesTheirMind(
			ThrowingConsumer<PreparedStatement> preparer) throws Throwable {
		try (var con = getConnection(true, true)) {
			for (String sql : new String[] { "INSERT INTO Foo(x) VALUES('Bar') RETURNING v$id",
					"INSERT INTO Foo(x) VALUES('Bar')" }) {
				var stmt = con.prepareStatement(sql);
				preparer.acceptThrows(stmt);
				assertThatExceptionOfType(SQLException.class).isThrownBy(stmt::getGeneratedKeys)
					.withMessageEndingWith("Generated keys have not been returned");
				stmt.close();
			}
		}
	}

	private static void assertMetaData(ResultSet rs) throws SQLException {
		var meta = rs.getMetaData();
		assertThat(meta).isNotNull();
		assertThat(meta.getColumnCount()).isOne();
		assertThat(meta.getColumnName(1)).isEqualTo("v$id");
	}

}
