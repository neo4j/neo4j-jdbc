= Quickstart

Add the JDBC driver to your application, for example as a Gradle dependency:

[source, kotlin, subs="verbatim,attributes"]]
.Using the full bundle as a runtime dependency inside a Gradle-based project
----
dependencies {
    runtimeOnly({group-id}:{artifact-id-full-bundle}:{version})
}
----

You can then use the Neo4j JDBC driver as you would do with any other JDBC driver.

[source, java, tabsize=4]
.Acquire a connection and execute a query
----
include::{examplesDir}/Quickstart.java[tag=pt1]
----
<.> Instantiate a JDBC connection. There's no need to do any class loading beforehand, the driver will be automatically registered
<.> Create a (reusable) statement
<.> Execute a query
<.> Iterate over the results, as with any other JDBC result set
<.> JDBC's indexing starts at 1
<.> JDBC also allows retrieval of result columns by name; the Neo4j JDBC driver also supports complex objects, such as lists

In the example above we used Neo4j's _lingua franca_, https://neo4j.com/docs/getting-started/cypher-intro/[Cypher], to query the database.
The Neo4j JDBC Driver has limited support for using SQL as well.
It can do so automatically, or on a case by case basis (which means?).
For the latter you can use `java.sql.Connection#nativeSQL(String)` and use the result in your queries.
For automatic translation instantiate the driver using the additional URL parameter `sql2cypher`, set to `true`.
The following example shows how:

[source, java, tabsize=4, indent=0]
.Configure the JDBC driver to automatically translate SQL to cypher.
----
include::{examplesDir}/Quickstart.java[tag=pt2]
----
<.> This SQL query will be translated into the same Cypher query of the previous example.
The remainder of the method is identical to before.

TIP: In case any tooling asks you for the name of the concrete driver class, it is `org.neo4j.jdbc.Neo4jDriver`.

For more information on the SQL-to-Cypher translation layer, see xref:s2c_introduction[].

The JDBC Spec does not support named parameters, only index-based parameters, starting at `1`.
So for all `PreparedStatement` instances you need to specify parameters like this:

[source, java, tabsize=4, indent=0]
.Using parameters with a `PreparedStatement`
----
include::{examplesDir}/NamedParameters.java[tag=index]
----

This is independent of the SQL-to-Cypher translation mechanism:

[source, java, tabsize=4, indent=0]
.Using parameters with a `PreparedStatement` (SQL variant)
----
include::{examplesDir}/NamedParameters.java[tag=index-sql]
----

To use named parameters, downcast the `PreparedStatement` to `Neo4jPreparedStatement`.

[source, java, tabsize=4, indent=0]
.Using named parameters with a `Neo4jPreparedStatement`
----
include::{examplesDir}/NamedParameters.java[tag=index-np]
----

== Getting a connection via environment variables

If you are happy to depend directly on `org.neo4j.jdbc.Neo4jDriver` and want to get a connection as easy as possible, you might want to use `fromEnv`:

[source, java, tabsize=4, indent=0]
.Get a connection from environment variables
----
include::{examplesDir}/Quickstart.java[tag=pt3]
----
<.> Notice how we directly use the concrete driver class here and how the methods return an optional: no connection can be created if the required connection variables are not found.

The `fromEnv` method looks for a few specific system environment variables and it adheres to the https://12factor.net[12 factor app] principles:

- First, it looks in the system environment
- Second, it looks for a file named `.env` in the current working directory. There are overloads that let you configure the directory and the filename to look for.

The supported variables are:

`NEO4J_URI`:: The address or URI of the instance to connect to.
`NEO4J_USERNAME`:: (Optional) Username.
`NEO4J_PASSWORD`:: (Optional) Password.
`NEO4J_SQL_TRANSLATION_ENABLED`:: (Optional) Whether to enable full SQL-to-Cypher translation, defaults to `false`.

NOTE: Information from both the system environment and the .env files are combined.
If for example `NEO4J_SQL_TRANSLATION_ENABLED` is in the system environment but not in the .env file, it will still be picked up.
Given the order of priority, information in the system environment always has preference with respect to the .env file.

This feature is especially useful with Neo4j AuraDB.
When creating a new AuraDB instance, you download a `.env` file that you can directly use with the Neo4j JDBC Driver:

[source,java]
.Using a .env file from AuraDB
----
try (
    var con = Neo4jDriver.fromEnv("Neo4j-cb3d8b2d-Created-2024-02-14.txt")
        .orElseThrow();
    var stmt = con.createStatement();
    var movies = stmt.executeQuery("MATCH (n:Movie) RETURN n.title AS title")
) {
    while (movies.next()) {
        System.out.println(movies.getString("title"));
    }
}
----
